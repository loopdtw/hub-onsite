'use strict'

var app = angular.module('HubApp', ['ngTouch', 'pageslide-directive', 'angular-duration-format']);

app.constant('config', {
	baseUrl: "https://internal-api.loopd.com/api/v1",
	authToken: '2lWYeQ1Bq3QOqzr43Swy6GMKNAX3Z07htTeqkDL4NLhLFeHFoyOYp5mIITZBAhQV'
});

app.config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode({
  		enabled: true,
  		requireBase: false
	});
}]);
angular.module('HubApp')
    .directive("hamburgerMenu", function() {
        return {
            restrict: "E",
            template: '<div></div><div></div><div></div>',
            scope: true,
            link: function($scope, elem) {
                elem.bind('click', function() {
                    $scope.$apply($scope.checked = !$scope.checked);
                });
            }
        };
    });
angular.module('HubApp')
    .directive('myEnter', function() {
        return function(scope, element, attrs) {
            element.bind("keydown keypress", function(event) {
                console.log('keypress');
                if (event.which === 13) {
                    scope.$apply(function() {
                        scope.$eval(attrs.myEnter);
                    });

                    event.preventDefault();
                }
            });
        };
    });
angular.module('HubApp')
    .controller('LookupController', function($scope, $http, $interval, $q, attendeeService, badgeService, $location, $timeout, $window) {
        $scope.eventId = null;
        $scope.currentAttendee = null;
        $scope.noAttendeeMessage = null;
        $scope.loading = false;

        //url location
        $scope.location = $location;
        $scope.$watch('location.search()', function() {
            $scope.eventId = ($location.search()).eventId;
            $scope.checkInWorker = ($location.search()).checkInWorker;
        }, true);

        $scope.changeTarget = function(name) {
            $location.search('eventId', name);
            $location.search('checkInWorker', name);
        }

        /*----------  MENU  ----------*/
        var toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        var goToSearch = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/search?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/search?eventId=' + $scope.eventId;
            }
        }

        var goToSignup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/signup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/signup?eventId=' + $scope.eventId;
            }
        }

        var goToCheckIn = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker
            } else {
                $window.location.href = '/?eventId=' + $scope.eventId;
            }
        }

        var goToLookup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/lookup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/lookup?eventId=' + $scope.eventId;
            }
        }

        /*----------  METHODS  ----------*/
        var close = function() {
            $('.badgeInfo').css('display', 'none');
            $scope.currentAttendee = null;
            $scope.noAttendeeMessage = null;
        }

        $scope.$on('badgeLookup', function(event, args) {
            if (!$scope.currentAttendee && !$scope.loading) {
                $('.badgeInfo').css('display', 'block');
                $scope.loading = true;
                attendeeService.getAttendeeForBadge($scope.eventId, args.identity)
                    .then(function(attendee) {
                        $scope.loading = false;
                        if (attendee) {
                            $scope.currentAttendee = attendee;
                        } else {
                            $scope.noAttendeeMessage = "No information found!"
                        }

                        $timeout(function() {
                            $('.badgeInfo').css('display', 'none');
                            $scope.currentAttendee = null;
                            $scope.noAttendeeMessage = null;
                        }, 3000);
                    });
            }
        });

        var init = function() {
            badgeService.enableLookup();
        }

        init();

        /*----------  EXPORT DECLARATIONS  ----------*/
        $scope.close = close;
        $scope.goToLookup = goToLookup;
        $scope.toggleMenu = toggleMenu;
        $scope.goToSearch = goToSearch;
        $scope.goToCheckIn = goToCheckIn;
        $scope.goToLookup = goToLookup;
        $scope.goToSignup = goToSignup;
    });
angular.module('HubApp')
    .controller('onsiteController', function($scope, $http, $timeout, $q, utilService, badgeService, attendeeService, $location, $window) {

        /*----------  VAR DECLARATIONS  ----------*/

        var existingBadges = [];
        var allAttendees = [];
        var alert = new Audio('/audio/alert.mp3');

        var syncTimeout = null;
        var getAttendeesTimeout = null;

        //we track the last user update time, giving an initial value of page load time
        var lastUserUpdateTime = new Date();

        /*----------  SCOPE VAR DECLARATIONS  ----------*/

        $scope.eventId = null;
        $scope.checkInWorker = null;
        $scope.currentAttendee = null;
        $scope.currentSyncedAttendee = null;
        $scope.currentlySyncing = false;
        $scope.currentlyUnsyncing = false;

        //checkin arrays
        $scope.unsyncedAttendees = [];
        $scope.syncedAttendees = [];

        //counts
        $scope.allocatedPeripheralsCount = 0;

        //menu
        $scope.checked = false;

        //url location
        $scope.location = $location;
        $scope.$watch('location.search()', function() {
            $scope.eventId = ($location.search()).eventId;
            $scope.checkInWorker = ($location.search()).checkInWorker;
        }, true);

        $scope.changeTarget = function(name) {
            $location.search('eventId', name);
            $location.search('checkInWorker', name);
        }

        /*----------  MENU  ----------*/
        var toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        var goToSearch = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/search?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/search?eventId=' + $scope.eventId;
            }
        }

        var goToSignup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/signup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/signup?eventId=' + $scope.eventId;
            }
        }

        var goToCheckIn = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker
            } else {
                $window.location.href = '/?eventId=' + $scope.eventId;
            }
        }

        var goToLookup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/lookup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/lookup?eventId=' + $scope.eventId;
            }
        }

        /*----------  FUNC DECLARATIONS  ----------*/
        var compare = function(a, b) {
            if (a.checkIn.created < b.checkIn.created)
                return -1;
            else if (a.checkIn.created > b.checkIn.created)
                return 1;
            else
                return 0;
        }

        var setCurrentAttendee = function(attendee) {
            if (!$scope.currentlySyncing) {
                if ($scope.currentAttendee) {
                    if ($scope.currentAttendee.id == attendee.id) {
                        $scope.currentAttendee = null;
                    } else {
                        $scope.currentAttendee = attendee;
                    }
                } else {
                    $scope.currentAttendee = attendee;
                }
            }
        }

        var setCurrentSyncedAttendee = function(attendee) {
            if (!$scope.currentlyUnsyncing) {
                if ($scope.currentSyncedAttendee) {
                    if ($scope.currentSyncedAttendee.id == attendee.id) {
                        $scope.currentSyncedAttendee = null;
                    } else {
                        $scope.currentSyncedAttendee = attendee;
                    }
                } else {
                    $scope.currentSyncedAttendee = attendee;
                }
            }
        }

        var processAttendees = function() {
            $scope.unsyncedAttendees = [];
            $scope.syncedAttendees = [];

            allAttendees.forEach(function(attendee) {
                if (!attendee.badge) {
                    $scope.unsyncedAttendees.push(attendee);
                } else {
                    $scope.syncedAttendees.push(attendee);
                }
            });
        }

        var removeBadgeForCheckIn = function(attendeeTemp) {
            allAttendees.forEach(function(attendee) {
                if (attendee.id == attendeeTemp.id) {
                    attendee.badge = null;
                }
            });
        }

        var addBadgeForCheckIn = function(attendeeTemp, badge) {
            allAttendees.forEach(function(attendee) {
                if (attendee.id == attendeeTemp.id) {
                    attendee.badge = badge;
                }
            });
        }

        var sendCommand = function(command) {
            if ($scope.currentSyncedAttendee.badge) {
                badgeService.sendCommand($scope.currentSyncedAttendee.badge, command);
            }
        }

        var sync = function() {
            var attendeeEmail = $scope.currentAttendee.email;

            if ($scope.currentAttendee && !$scope.currentlySyncing && badgeService.allocatedPeripheralsCount > 0) {
                $scope.currentlySyncing = true;
                badgeService.syncBadge($scope.currentAttendee);
            }

            setSyncTimeout(attendeeEmail);
        }

        var unsync = function() {
            if (!$scope.currentlyUnsyncing && $scope.currentSyncedAttendee && $scope.currentSyncedAttendee.badge) {
                $scope.currentlyUnsyncing = true;
                badgeService.unsyncBadge($scope.currentSyncedAttendee, $scope.currentSyncedAttendee.badge)
                    .then(function() {
                        removeBadgeForCheckIn($scope.currentSyncedAttendee);
                        processAttendees();

                        var existingAttendeeBadges = {};
                        allAttendees.forEach(function(attendee) {
                            if (attendee.badge) {
                                var uniqueId = attendee.badge.identity + attendee.badge.macAddress;
                                existingAttendeeBadges[uniqueId] = attendee.badge;
                            }
                        });
                        badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);

                        $scope.currentSyncedAttendee = null;
                        $scope.currentlyUnsyncing = false;
                        lastUserUpdateTime = new Date();
                    });
            }
        }

        //we have sync timeout here to force the sync button to go back if we don't get a socket message that our badge has been synced
        var setSyncTimeout = function(attendeeEmail) {
            syncTimeout = $timeout(function() {
                console.log('timed out, looking for record!', $scope.eventId, attendeeEmail);
                attendeeService.getAttendeeByEmail($scope.eventId, attendeeEmail)
                    .then(function(attendees) {
                        var attendee = attendees[0];
                        if (attendee.badge) {
                            completeSync(attendee, attendee.badge);
                        } else {
                            setSyncTimeout(attendeeEmail);
                        }
                    });
            }, 3 * 1000);
        }

        var completeSync = function(attendeeTemp, badge) {
            $scope.unsyncedAttendees.forEach(function(attendee) {
                if (attendee.id == attendeeTemp.id) {
                    addBadgeForCheckIn(attendee, badge);
                    processAttendees();
                }
            });

            if ($scope.unsyncedAttendees.length > 0) {
                $scope.currentAttendee = $scope.unsyncedAttendees[0];
            } else {
                $scope.currentAttendee = null;
            }
            $scope.currentlySyncing = false;

            lastUserUpdateTime = new Date();
            alert.play();
        }

        /*----------  INIT FUNCTION DECLARATIONS  ----------*/

        var getAttendeeCheckIns = function() {
            attendeeService.getCheckIns($scope.eventId, $scope.checkInWorker, "")
                .then(function(result) {
                    if ($scope.checkInWorker) {
                        allAttendees = result.attendees.sort(function(a, b) {
                            return (a.checkIn.created < b.checkIn.created) ? 1 : ((b.checkIn.created < a.checkIn.created) ? -1 : 0);
                        });
                    } else {
                        allAttendees = result.attendees;
                    }

                    //here we make sure that the polling time is
                    if (result.requestTime > lastUserUpdateTime) {
                        processAttendees();
                    } else {
                        console.log('request too old to update ui!');
                    }
                })
                .finally(function() {
                    var existingAttendeeBadges = {};
                    allAttendees.forEach(function(attendee) {
                        if (attendee.badge) {
                            var uniqueId = attendee.badge.identity + attendee.badge.macAddress;
                            existingAttendeeBadges[uniqueId] = attendee.badge;
                        }
                    });
                    $scope.currentStatus = badgeService.currentStatus;
                    // console.log(new Date(), 'updated checkins');
                });

            getAttendeesTimeout = $timeout(function() {
                getAttendeeCheckIns();
            }, 2 * 1000);
        }

        getAttendeeCheckIns();

        /*----------  EVENT LISTENERS  ----------*/

        $scope.$on('badgeSynced', function(event, args) {
            if (syncTimeout) {
                $timeout.cancel(syncTimeout);
            }

            completeSync(args.attendee, args.badge);
        });

        $scope.$on('badgeSyncError', function(event, args) {
            $scope.currentlySyncing = false;
            if (syncTimeout) {
                $timeout.cancel(syncTimeout);
            }
            $scope.$apply();
        });

        $scope.$on('badgeDisconnect', function() {
            $scope.currentlySyncing = false;
            if (syncTimeout) {
                $timeout.cancel(syncTimeout);
            }
            $scope.$apply();
        });

        $scope.$on('currentStatus', function() {
            $scope.currentStatus = badgeService.currentStatus;
            $scope.$apply();
        });

        $scope.$on('currentBadges', function() {
            $scope.$apply($scope.allocatedPeripheralsCount = badgeService.allocatedPeripheralsCount);
        });

        /*----------  EXPORT DECLARATIONS  ----------*/
        $scope.setCurrentAttendee = setCurrentAttendee;
        $scope.setCurrentSyncedAttendee = setCurrentSyncedAttendee;
        $scope.sendCommand = sendCommand;
        $scope.toggleMenu = toggleMenu;
        $scope.sync = sync;
        $scope.unsync = unsync;
        $scope.goToSearch = goToSearch;
        $scope.goToCheckIn = goToCheckIn;
        $scope.goToLookup = goToLookup;
        $scope.goToSignup = goToSignup;
    });
angular.module('HubApp')
    .controller('searchController', function($scope, $http, $timeout, $q, utilService, socketService, badgeService, attendeeService, $location, $window) {

        /*----------  VAR DECLARATIONS  ----------*/
        var syncTimeout = null;

        /*----------  SCOPE VAR DECLARATIONS  ----------*/
        $scope.eventId = null;
        $scope.checkInWorker = null;
        $scope.currentAttendee = null;
        $scope.currentSyncedAttendee = null;
        $scope.currentlySyncing = false;
        $scope.currentlyUnsyncing = false;

        //search
        $scope.searchTerm = null;

        var searchResults = [];
        $scope.currentlySearching = false;
        $scope.syncedSearchResults = [];
        $scope.unsyncedSearchResults = [];

        //counts
        $scope.allocatedBadgesCount = 0;

        //menu
        $scope.checked = false;

        //url location
        $scope.location = $location;
        $scope.$watch('location.search()', function() {
            $scope.eventId = ($location.search()).eventId;
            $scope.checkInWorker = ($location.search()).checkInWorker;
            cacheAttendees();
        }, true);

        $scope.changeTarget = function(name) {
            $location.search('eventId', name);
            $location.search('checkInWorker', name);
        }

        /*----------  MENU  ----------*/
        var toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        var goToSearch = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/search?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/search?eventId=' + $scope.eventId;
            }
        }

        var goToSignup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/signup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/signup?eventId=' + $scope.eventId;
            }
        }

        var goToCheckIn = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker
            } else {
                $window.location.href = '/?eventId=' + $scope.eventId;
            }
        }

        var goToLookup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/lookup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/lookup?eventId=' + $scope.eventId;
            }
        }

        /*----------  FUNC DECLARATIONS  ----------*/

        var toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        var setCurrentAttendee = function(attendee) {
            if (!$scope.currentlySyncing) {
                if ($scope.currentAttendee) {
                    if ($scope.currentAttendee.id == attendee.id) {
                        $scope.currentAttendee = null;
                    } else {
                        $scope.currentAttendee = attendee;
                    }
                } else {
                    $scope.currentAttendee = attendee;
                }
            }
        }

        var setCurrentSyncedAttendee = function(attendee) {
            if (!$scope.currentlyUnsyncing) {
                if ($scope.currentSyncedAttendee) {
                    if ($scope.currentSyncedAttendee.id == attendee.id) {
                        $scope.currentSyncedAttendee = null;
                    } else {
                        $scope.currentSyncedAttendee = attendee;
                    }
                } else {
                    $scope.currentSyncedAttendee = attendee;
                }
            }
        }

        var removeBadgeForAttendee = function(attendeeTemp) {
            searchResults.forEach(function(attendee) {
                if (attendee.id == attendeeTemp.id) {
                    attendee.badge = null;
                }
            });
        }

        var addBadgeForAttendee = function(attendeeTemp, badge) {
            searchResults.forEach(function(attendee) {
                if (attendee.id == attendeeTemp.id) {
                    attendee.badge = badge;
                }
            });
        }

        var searchCachedAttendees = function() {
            searchResults = [];
            if ($scope.searchTerm.length && $scope.searchTerm.length >= 3) {
                var regex = new RegExp($scope.searchTerm, "i");
                $scope.cachedAttendees.forEach(function(attendee) {
                    if (attendee.email.search(regex) > -1) {
                        searchResults.push(attendee);
                    } else if (typeof attendee.firstname !== 'undefined' && attendee.firstname.search(regex) > -1) {
                        searchResults.push(attendee);
                    } else if (typeof attendee.lastname !== 'undefined' && attendee.lastname.search(regex) > -1) {
                        searchResults.push(attendee);
                    } else if (typeof attendee.providerAttendeeId !== 'undefined' && attendee.providerAttendeeId.search(regex) > -1) {
                        searchResults.push(attendee);
                    }
                });
            }
            processSearchResults();
        }

        var search = function() {
            if (search && search !== "") {
                $scope.currentlySearching = true;
                attendeeService.searchAttendees($scope.eventId, $scope.searchTerm)
                    .then(function(data) {
                        $scope.currentlySearching = false;
                        searchResults = data.data;
                        processSearchResults();
                    });
            }
        }

        var processSearchResults = function() {
            $scope.syncedSearchResults = [];
            $scope.unsyncedSearchResults = [];

            searchResults.forEach(function(result) {
                if (result.badge) {
                    $scope.syncedSearchResults.push(result);
                } else {
                    $scope.unsyncedSearchResults.push(result);
                }
            });
        }

        var sendCommand = function(command) {
            if ($scope.currentSyncedAttendee.badge) {
                badgeService.sendCommand($scope.currentSyncedAttendee.badge, command);
            }
        }

        var sync = function() {
            if ($scope.currentAttendee && !$scope.currentlySyncing && badgeService.allocatedPeripheralsCount > 0) {
                var attendeeEmail = $scope.currentAttendee.email;
                $scope.currentlySyncing = true;
                badgeService.syncBadge($scope.currentAttendee);
                setSyncTimeout(attendeeEmail);
            }
        }

        var setSyncTimeout = function(attendeeEmail) {
            syncTimeout = $timeout(function() {
                console.log('timed out, looking for record!');
                attendeeService.getAttendeeByEmail($scope.eventId, attendeeEmail)
                    .then(function(attendees) {
                        var attendee = attendees[0];
                        if (attendee.badge) {
                            completeSync(attendee, attendee.badge);
                        } else {
                            setSyncTimeout();
                        }
                    });
            }, 3 * 1000);
        }

        var unsync = function() {
            if (!$scope.currentlyUnsyncing && $scope.currentSyncedAttendee && $scope.currentSyncedAttendee.badge) {
                $scope.currentlyUnsyncing = true;
                var existingAttendeeBadges = {};
                badgeService.unsyncBadge($scope.currentSyncedAttendee, $scope.currentSyncedAttendee.badge)
                    .then(function() {
                        removeBadgeForAttendee($scope.currentSyncedAttendee);
                        processSearchResults();

                        var existingAttendeeBadges = {};
                        searchResults.forEach(function(attendee) {
                            if (attendee.badge) {
                                var uniqueId = attendee.badge.identity + attendee.badge.macAddress;
                                existingAttendeeBadges[uniqueId] = attendee.badge;
                            }
                        });
                        badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);

                        $scope.currentSyncedAttendee = null;
                        $scope.currentlyUnsyncing = false;
                    });
            }
        }

        var completeSync = function(attendee, badge) {
            addBadgeForAttendee(attendee, badge);
            processSearchResults();
            $scope.currentlySyncing = false;
        }

        // init controllers        
        var cacheAttendees = function() {
            if ($scope.eventId) {
                attendeeService.getAttendeesForEvent($scope.eventId).then(function(attendees) {
                    console.log(attendees.length + " attendees cached!");
                    $scope.cachedAttendees = attendees;
                });
            }

            setTimeout(function() {
                cacheAttendees();
            }, 5 * 60 * 1000);
        }

        cacheAttendees();

        /*----------  EVENT LISTENERS  ----------*/

        $scope.$on('badgeSynced', function(event, args) {
            if (syncTimeout) {
                $timeout.cancel(syncTimeout);
            }

            completeSync(args.attendee, args.badge);

            alert.play();
            $scope.$apply();
        });

        $scope.$on('badgeDisconnect', function() {
            $scope.currentlySyncing = false;
            $scope.$apply();
        });

        $scope.$on('currentStatus', function() {
            $scope.currentStatus = badgeService.currentStatus;
            $scope.$apply();
        });

        $scope.$on('currentBadges', function() {
            $scope.$apply($scope.allocatedPeripheralsCount = badgeService.allocatedPeripheralsCount);
        });

        /*----------  EXPORT DECLARATIONS  ----------*/
        $scope.searchCachedAttendees = searchCachedAttendees;
        $scope.search = search;
        $scope.toggleMenu = toggleMenu;
        $scope.setCurrentAttendee = setCurrentAttendee;
        $scope.setCurrentSyncedAttendee = setCurrentSyncedAttendee;
        $scope.sendCommand = sendCommand;
        $scope.sync = sync;
        $scope.unsync = unsync;
        $scope.goToSearch = goToSearch;
        $scope.goToCheckIn = goToCheckIn;
        $scope.goToLookup = goToLookup;
        $scope.goToSignup = goToSignup;
    });
angular.module('HubApp')
	.factory('attendeeService', function($rootScope, $q, $http, utilService, socketService, config) {
		var attendeeService = {};
		var socket = socketService.socket;

		var ATTENDEE_LIMIT = 20;

		attendeeService.currentSyncingAttendee = null;
		attendeeService.existingAttendeeBadges = {};

		var getCheckIns = function(eventId, workerId, keyword) {
			var deferred = $q.defer();
			var url = "";

			var deferred = $q.defer();
			var requestTime = new Date();
			if (workerId) {
				url = config.baseUrl + '/onsite/attendees?checkInWorker=' + workerId;
			} else {
				url = config.baseUrl + '/onsite/attendees';
			}

			$http({
				method: 'GET',
				url: url,
				params: {
					"eventId": eventId,
					"limit": ATTENDEE_LIMIT
				}
			}).
			then(function(res) {
				deferred.resolve({
					attendees: res.data,
					requestTime: requestTime
				});

			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var searchAttendees = function(eventId, keyword) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/onsite/attendees/search';
			$http({
				method: 'GET',
				url: url,
				params: {
					"eventId": eventId,
					"q": keyword
				}
			}).
			then(function(res) {
				deferred.resolve(res);
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var getAttendeesForEvent = function(eventId) {
			var deferred = $q.defer();
			$http({
				method: 'GET',
				url: config.baseUrl + '/events/' + eventId + '/eventattendees',
				headers: {
					'Loopd-Admin-Key': config.authToken
				},
				params: {
					"requestFrom": "home",
					"requestFromId": "unknown"
				}
			}).
			then(function(res) {
				deferred.resolve(res.data);
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var getAttendeeByEmail = function(eventId, email) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/onsite/attendees/search';
			$http({
				method: 'GET',
				url: url,
				params: {
					"eventId": eventId,
					"q": email
				}
			}).
			then(function(res) {
				console.log(res);
				deferred.resolve(res.data);
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var getAttendeeForBadge = function(eventId, identity) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/Events/' + eventId + '/eventattendees';
			console.log(url);
			$http({
				method: 'GET',
				url: url,
				headers: {
					'Loopd-Admin-Key': config.authToken
				},
				params: {
					"requestFrom": "WEB",
					"requestFromId": 123,
					"badge": identity
				}
			}).
			then(function(res) {
				if (res.data.length > 0) {
					deferred.resolve(res.data[0]);
				} else {
					deferred.resolve(null);
				}
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var findAvailableBadgeForAttendee = function(attendee) {
			attendeeService.currentSyncingAttendee = attendee;

			$http({
				method: 'POST',
				url: '/sync-one',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					currentAttendee: attendee,
					rssiThreshold: $scope.rssiThreshold
				}
			}).
			success(function(data, status, headers, config) {

			}).
			error(function(data, status, headers, config) {
				console.error(data);
			});
		}

		var signupAttendee = function(eventId, attendee) {
			var deferred = $q.defer();

			var signupAttendee = {
				eventId: eventId,
				firstname: attendee.firstname,
				lastname: attendee.lastname,
				email: attendee.email,
				title: attendee.title,
				organization: attendee.organization,
				provider: attendee.provider,
				providerAttendeeId: attendee.providerAttendeeId,
				checkInWorker: attendee.checkInWorker
			};

			console.log(signupAttendee);

			$http({
				method: 'POST',
				url: '/signup',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					attendee: signupAttendee
				}
			}).
			success(function(data, status, headers, config) {
				console.log(data);
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				console.log(data);
				deferred.reject(data);
			});

			return deferred.promise;
		}

		/*----------  EXPORT DECLARTIONS  ----------*/
		attendeeService.getCheckIns = getCheckIns;
		attendeeService.searchAttendees = searchAttendees;
		attendeeService.getAttendeesForEvent = getAttendeesForEvent;
		attendeeService.getAttendeeByEmail = getAttendeeByEmail;
		attendeeService.getAttendeeForBadge = getAttendeeForBadge;
		attendeeService.signupAttendee = signupAttendee;

		return attendeeService;
	});
angular.module('HubApp')
	.factory('badgeService', function($rootScope, $q, $http, utilService, socketService, attendeeService, config, $timeout) {
		var badgeService = {};
		var socket = socketService.socket;
		var socketConnected = false;

		/*----------  VAR DECLARATIONS  ----------*/

		badgeService.currentStatus = 'Waiting for command...';
		badgeService.seenBadgesCount = 0;
		badgeService.currentBadges = [];
		badgeService.currentAvailableBadges = [];
		badgeService.seenBadges = {};
		badgeService.attendeesWaitingToSync = {};
		badgeService.badgesWaitingForCommand = {};
		badgeService.existingAttendeeBadges = {};
		badgeService.rssiThreshold = "...";
		badgeService.isScanning = false;
		badgeService.bulkCommanding = false;

		//peripheral counts
		badgeService.availablePeripheralsCount = 0;
		badgeService.allocatedPeripheralsCount = 0;

		/*----------  FUNC DECLARATIONS  ----------*/

		//resets the count of seenbadges
		var reset = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/reset',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				badgeService.seenBadges = {};
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//toggles allocation of badges where speed is increased if nearby
		var allocate = function() {
			var deferred = $q.defer();

			$http({
				method: 'GET',
				url: '/allocate',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		var scanForInterval = function(scanTime, detectDuplicates) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/scan',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					scanTime: scanTime,
					detectDuplicates: detectDuplicates
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		var scanForAvailable = function(scanTime) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/scan',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					scanTime: scanTime,
					onlyAvailable: true
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//sends a designated command to the badge
		var sendCommand = function(badge, command) {
			var uniqueId = badge.identity + badge.macAddress;
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/command-badge',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					badge: badge,
					badgeCommand: command
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				delete badgeService.badgesWaitingForCommand[uniqueId];
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//sends a designated command to the badge
		var sendBulkCommand = function(state, command) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/bulk-command',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					state: state,
					bulkBadgeCommand: command
				}
			}).
			success(function(data, status, headers, config) {
				badgeService.bulkCommanding = true;
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		var cancelBulkCommand = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/cancel-bulk-command',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				badgeService.bulkCommanding = false;
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//tells the backend to communicate with the server to tie the badge id to attendee
		var syncBadge = function(attendee) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/sync-badge',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					attendee: attendee
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				delete badgeService.badgesWaitingForCommand[attendee.id];
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//sets the rssi threshold in which commands/synchronizations can be sent
		var setRssiThreshold = function(value) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/set-rssi',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					rssiThreshold: $scope.rssiThreshold
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		//takes in an object with idMac as unique key with value as badge object
		var updateExistingAttendeeBadges = function(existingAttendeeBadges) {
			var deferred = $q.defer();
			badgeService.existingAttendeeBadges = existingAttendeeBadges;

			$http({
				method: 'POST',
				url: '/update-existing-badges',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					existingBadges: badgeService.existingAttendeeBadges,
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		var unsyncBadge = function(attendee, badge) {
			var deferred = $q.defer();
			var baseConfig = config;

			$http({
				method: 'POST',
				url: '/unsync-badge',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					badge: badge
				}
			}).
			success(function(data) {
				$http({
					method: 'DELETE',
					url: config.baseUrl + '/Events/' + attendee.eventId + '/badges/' + badge.identity,
					headers: {
						'Loopd-Admin-Key': config.authToken
					},
					params: {
						"source": "WEB_E",
						"sourceId": "WE:WE:WE",
						"isReturned": true
					}
				}).
				success(function(data, status, headers, config) {
					attendee.badgeIdentity = null;
					deferred.resolve(data);
				}).
				error(function(data, status, headers, config) {
					deferred.reject(data);
				});

			}).
			error(function(data, status, headers, config) {
				deferred.reject();
			});

			return deferred.promise;
		}

		var setRssiThreshold = function(rssiThreshold) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/rssi-threshold',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					rssiThreshold: rssiThreshold,
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve();
			}).
			error(function(data, status, headers, config) {
				deferred.reject();
			});

			return deferred.promise;
		}

		//this turns on the trigger functionality
		var enableLookup = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/enable-lookup',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		/*----------  SOCKET LISTENERS  ----------*/

		socket.on('currentStatus', function(data) {
			badgeService.currentStatus = data.status.toString();
			console.log(data.status.toString());
			$rootScope.$broadcast('currentStatus');
		});

		socket.on('alert', function(data) {
			alert(data.message);
		});

		socket.on('logMessage', function(data) {
			console.log('%c (' + new Date().toLocaleTimeString() + ') ' + data.log, 'color: #009afd');
		});

		socket.on('currentBadges', function(data) {
			badgeService.currentBadges = data.currentBadges;
			badgeService.currentAvailableBadges = data.currentAvailableBadges;
			badgeService.allocatedPeripheralsCount = data.allocatedPeripheralsCount;
			badgeService.availablePeripheralsCount = data.availablePeripheralsCount;
			$rootScope.$broadcast('currentBadges');
		});

		socket.on('badgeCommand', function(data) {
			var uniqueId = data.badge.identity + data.badge.macAddress;
			delete badgeService.badgesWaitingForCommand[uniqueId];
		});

		socket.on('badgeConnected', function(data) {
			if (data.connected == true) {
				$scope.$apply($scope.badgeConnected = true);
			} else {
				$scope.$apply($scope.badgeConnected = false);
			}
		});

		socket.on('badgeSynced', function(data) {
			$rootScope.$broadcast('badgeSynced', {
				attendee: data.attendee,
				badge: data.badge
			});
		});

		socket.on('badgeSyncError', function(data) {
			$rootScope.$broadcast('badgeSyncError', {
				attendee: data.attendee,
				badge: data.badge
			});
		});

		socket.on('badgeDisconnect', function(data) {
			console.log('badge disconnect called!');
			$rootScope.$broadcast('badgeDisconnect');
		});

		socket.on('badgeNotFound', function(data) {
			alert(data.message);
			$rootScope.$broadcast('badgeNotFound');
		});

		socket.on('badgeLookup', function(data) {
			console.log('badge service', 'badge lookup');
			$rootScope.$broadcast('badgeLookup', {
				identity: data.identity
			});
		});

		socket.on('bulkCommandComplete', function() {
			badgeService.bulkCommanding = false;
			$rootScope.$broadcast('bulkCommandComplete');
		});

		socket.on('connect', function() {
			console.log("socket connection");
			socketConnected = true;
		});

		socket.on('disconnect', function() {
			console.log('socket disconnection!');
			socketConnected = false;
			retryConnection();
		});

		var retryConnection = function() {
			if (!socketConnected) {
				socket.connect();
			}

			$timeout(function() {
				retryConnection();
			}, 1000);
		}

		/*----------  EXPORT DECLARATIONS  ----------*/
		badgeService.reset = reset;
		badgeService.sendCommand = sendCommand;
		badgeService.sendBulkCommand = sendBulkCommand;
		badgeService.syncBadge = syncBadge;
		badgeService.unsyncBadge = unsyncBadge;
		badgeService.updateExistingAttendeeBadges = updateExistingAttendeeBadges;
		badgeService.allocate = allocate;
		badgeService.scanForInterval = scanForInterval;
		badgeService.setRssiThreshold = setRssiThreshold;
		badgeService.enableLookup = enableLookup;

		return badgeService;
	});
'use strict';
angular.module('HubApp')
    .factory('loginService', function($http) {
        return {
            loginAsync: function(username, password) {
                return $http.post('/api/v1/login', {
                    username: username,
                    password: password
                }).success(function(data, status) {
                    return data;
                }).error(function(data, status) {
                    console.log('fail to login with response:', data);
                });
            }
        };
    });

angular.module('HubApp')
	.factory('socketService', function() {
		var socket = io.connect();
		return {
			socket: socket
		}
	});
angular.module('HubApp')
	.factory('utilService', function() {
		var util = {};

		/*----------  ARRAY METHODS  ----------*/
		var arrayContains = function(needle, arrhaystack) {
			return (arrhaystack.indexOf(needle) > -1);
		}

		var removeFromArray = function(needle, arrhaystack) {
			var index = arrhaystack.map(function(x) {
				return needle;
			}).indexOf(needle);
			arrhaystack.splice(index, 1);
		}

		var objectExistsInArray = function(prop, value, arrhaystack) {
			arrhaystack.forEach(function(object) {
				if (object[prop] === value) {
					return true;
				}
			});

			return false;
		}

		var findObjectInArray = function(prop, value, arrhaystack) {
			arrhaystack.forEach(function(object, index) {
				if (object[prop] === value) {
					return index;
				}
			});

			return -1;
		}

		var findIndexByIdentityAndMac = function(identity, macAddress, arrayhaystack) {
			for (var i = 0; i < arrayhaystack.length; i += 1) {
				if (arrayhaystack[i]['macAddress'] === macAddress && arrayhaystack[i]['identity'] === identity) {
					return i;
				}
			}

			return -1;
		}

		var getSortedArrayFromObject = function(property, object, reverse) {
			return Object.keys(object).sort(function(a, b) {
				var aProp = (typeof object[a][property] === 'undefined' || object[a][property] === null) ? 0 : object[a][property];
				var bProp = (typeof object[b][property] === 'undefined' || object[b][property] === null) ? 0 : object[b][property];

				if (reverse) {
					return bProp - aProp;
				} else {
					return aProp - bProp;
				}
			});
		}

		util.arrayContains = arrayContains;
		util.removeFromArray = removeFromArray;
		util.objectExistsInArray = objectExistsInArray;
		util.findObjectInArray = findObjectInArray;
		util.findIndexByIdentityAndMac = findIndexByIdentityAndMac;
		util.getSortedArrayFromObject = getSortedArrayFromObject;

		return util;
	});
angular.module('HubApp')
    .controller('signupController', function($scope, $http, $timeout, $q, utilService, socketService, badgeService, attendeeService, $location, $window) {

        /*----------  SCOPE VAR DECLARATIONS  ----------*/
        $scope.eventId = null;
        $scope.checkInWorker = null;
        $scope.currentlyLoading = false;

        //menu
        $scope.checked = false;

        //url location
        $scope.location = $location;
        $scope.$watch('location.search()', function() {
            $scope.eventId = ($location.search()).eventId;
            $scope.checkInWorker = ($location.search()).checkInWorker;

            $scope.currentAttendee = {
                firstname: null,
                lastname: null,
                email: null,
                line: null,
                title: null,
                organization: null,
                provider: 'loopd',
                providerAttendeeId: $scope.checkInWorker + new Date().valueOf(),
                checkInWorker: $scope.checkInWorker
            }

        }, true);

        $scope.changeTarget = function(name) {
            $location.search('eventId', name);
            $location.search('checkInWorker', name);
        }

        /*----------  MENU  ----------*/
        var toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        var goToSearch = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/search?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/search?eventId=' + $scope.eventId;
            }
        }

        var goToSignup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/signup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/signup?eventId=' + $scope.eventId;
            }
        }

        var goToCheckIn = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker
            } else {
                $window.location.href = '/?eventId=' + $scope.eventId;
            }
        }

        var goToLookup = function() {
            if ($scope.checkInWorker) {
                $window.location.href = '/lookup?eventId=' + $scope.eventId + '&checkInWorker=' + $scope.checkInWorker;
            } else {
                $window.location.href = '/lookup?eventId=' + $scope.eventId;
            }
        }

        /*----------  FUNC DECLARATIONS  ----------*/

        var signup = function() {
            $scope.currentlyLoading = true;
            console.log('onsite controller', $scope.currentAttendee);
            attendeeService.signupAttendee($scope.eventId, $scope.currentAttendee)
                .then(function(data) {
                    $scope.currentlyLoading = false;
                });
        }

        /*----------  INIT FUNCTION DECLARATIONS  ----------*/


        /*----------  EXPORT DECLARATIONS  ----------*/
        $scope.signup = signup;
        $scope.toggleMenu = toggleMenu;
        $scope.goToSignup = goToSignup;
        $scope.goToSearch = goToSearch;
        $scope.goToCheckIn = goToCheckIn;
        $scope.goToLookup = goToLookup;
        $scope.goToSignup = goToSignup;
    });