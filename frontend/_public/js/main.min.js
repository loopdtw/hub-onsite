'use strict'

var app = angular.module('HubApp', ['ngTouch', 'pageslide-directive', 'angular-duration-format']);

app.constant('config', {
	baseUrl: "https://internal-api.loopd.com/api/v1",
	authToken: '2lWYeQ1Bq3QOqzr43Swy6GMKNAX3Z07htTeqkDL4NLhLFeHFoyOYp5mIITZBAhQV'
});

app.config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode({
  		enabled: true,
  		requireBase: false
	});
}]);
angular.module('HubApp')
    .controller('BadgeStateController', function($scope, $http, $interval, $q, badgeService, utilService, config) {
        var socket = io.connect();

        /*----------  VAR DECLARATIONS  ----------*/

        var predicate = null;
        var reverse = false;

        /*----------  SCOPE VAR DECLARATIONS  ----------*/
        $scope.scanTime = 5;
        $scope.badgeCommands = {};
        $scope.sortedKeys = [];

        $scope.isScanning = badgeService.isScanning;
        $scope.currentStatus = badgeService.currentStatus;
        $scope.seenBadges = badgeService.seenBadges;
        $scope.seenBadgesCount = badgeService.seenBadgesCount;
        $scope.currentBadgesCount = badgeService.currentBadgesCount;

        $scope.bulkState = "";
        $scope.bulkCommand = "";

        $scope.bulkCommanding = false;

        /*----------  FUNCTION DECLARATIONS  ----------*/

        var order = function(item) {
            predicate = item;
            reverse = ~reverse;
            $scope.sortedKeys = utilService.getSortedArrayFromObject(predicate, badgeService.seenBadges, reverse);
        }

        var reset = function() {
            badgeService.reset();
            $scope.sortedKeys = [];
        }

        var scanForInterval = function() {
            $scope.isScanning = true;
            badgeService.scanForInterval($scope.scanTime, false)
                .then(function(isScanning) {
                    $scope.isScanning = false;
                });
        }

        var sendBadgeCommand = function(badge) {
            badgeService.sendCommand(badge, $scope.badgeCommands[badge.identity + badge.macAddress]);
        }

        var sendBulkCommand = function() {
            $scope.bulkCommanding = true;
            badgeService.sendBulkCommand($scope.bulkState, $scope.bulkCommand);
        }

        var badgeWaitingForCommand = function(badge) {
            var uniqueId = badge.identity + badge.macAddress;
            return badgeService.hasOwnProperty(uniqueId);
        }

        var updateKeys = function(badges) {
            for (var key in badges) {
                console.log(key);
                if (!utilService.arrayContains(key, $scope.sortedKeys)) {
                    $scope.sortedKeys.push(key);
                }
            }
        }

        /*----------  INIT DECLARATIONS  ----------*/

        function getInitialData() {
            var deferred = $q.defer();
            $http({
                    method: 'GET',
                    url: '/initial-data'
                })
                .then(function(res) {
                    $scope.currentVersion = (res.data.currentVersion);
                    deferred.resolve();
                })
                .catch(function(err) {
                    deferred.reject(err);
                });

            return deferred.promise;
        }

        function init() {
            getInitialData()
                .then(function() {
                    console.log('init complete');
                });
        }

        init();

        /*----------  EVENT LISTENTERS  ----------*/
        $scope.$on('seenBadges', function() {
            $scope.$apply($scope.seenBadges = badgeService.seenBadges);
            updateKeys(badgeService.seenBadges);
        });

        $scope.$on('currentStatus', function() {
            console.log('currentStatus!');
            $scope.currentStatus = badgeService.currentStatus;
            $scope.$apply();
        });

        $scope.$on('bulkCommandComplete', function() {
            $scope.bulkCommanding = badgeService.bulkCommanding;
            $scope.$apply();
        });

        $scope.$on('currentBadges', function() {
            $scope.$apply($scope.seenBadges = badgeService.seenBadges);
            $scope.$apply($scope.seenBadgesCount = badgeService.seenBadgesCount);
            $scope.$apply($scope.currentBadgesCount = badgeService.currentBadgesCount);
            updateKeys(badgeService.seenBadges);
        });

        /*----------  EXPORTED FUNCTIONS  ----------*/
        $scope.scanForInterval = scanForInterval;
        $scope.sendBadgeCommand = sendBadgeCommand;
        $scope.sendBulkCommand = sendBulkCommand;
        $scope.badgeWaitingForCommand = badgeWaitingForCommand;
        $scope.order = order;
        $scope.reset = reset;
    });
angular.module('HubApp')
    .directive("hamburgerMenu", function() {
        return {
            restrict: "E",
            template: '<div></div><div></div><div></div>',
            scope: true,
            link: function($scope, elem) {
                elem.bind('click', function() {
                    $scope.$apply($scope.checked = !$scope.checked);
                });
            }
        };
    });
angular.module('HubApp')
    .directive('myEnter', function() {
        return function(scope, element, attrs) {
            element.bind("keydown keypress", function(event) {
                console.log('keypress');
                if (event.which === 13) {
                    scope.$apply(function() {
                        scope.$eval(attrs.myEnter);
                    });

                    event.preventDefault();
                }
            });
        };
    });
angular.module('HubApp')
	.controller('DuplicatesController', function($scope, $http, $interval, $q, badgeService, utilService, config) {
		var socket = io.connect();

		/*----------  VAR DECLARATIONS  ----------*/

		var predicate = null;
		var reverse = false;

		var idBadges = {};
		var macBadges = {};
		$scope.repeatedIdBadges = {};
		$scope.repeatedMacBadges = {};


		/*----------  SCOPE VAR DECLARATIONS  ----------*/
		$scope.scanTime = 5;
		$scope.badgeCommands = {};
		$scope.sortedKeys = [];

		$scope.isScanning = badgeService.isScanning;
		$scope.currentStatus = badgeService.currentStatus;
		$scope.seenBadges = badgeService.seenBadges;
		$scope.seenBadgesCount = badgeService.seenBadgesCount;
		$scope.currentBadgesCount = badgeService.currentBadgesCount;

		/*----------  FUNCTION DECLARATIONS  ----------*/

		var order = function(item) {
			predicate = item;
			reverse = ~reverse;
			$scope.sortedKeys = utilService.getSortedArrayFromObject(predicate, badgeService.seenBadges, reverse);
		}

		var reset = function() {
			badgeService.reset();
			idBadges = {};
			macBadges = {};
			$scope.repeatedIdBadges = {};
			$scope.repeatedMacBadges = {};
			$scope.$apply();
		}

		var scanForInterval = function() {
			$scope.isScanning = true;
			badgeService.scanForInterval($scope.scanTime, true)
				.then(function(isScanning) {
					$scope.isScanning = false;
				});
		}

		var compileBadgesById = function() {
			for (var key in badgeService.seenBadges) {
				var badge = badgeService.seenBadges[key];

				//detecting duplicates by id
				if (typeof idBadges[badge.identity] !== 'undefined') {
					if (!utilService.arrayContains(badge.macAddress, idBadges[badge.identity].macAddresses)) {
						idBadges[badge.identity].macAddresses.push(badge.macAddress);
						$scope.repeatedIdBadges[badge.identity] = idBadges[badge.identity];
					}
				} else {
					idBadges[badge.identity] = {
						macAddresses: [badge.macAddress]
					}
				}

				//detecting duplicates by mac
				if (typeof macBadges[badge.macAddress] !== 'undefined') {
					if (!utilService.arrayContains(badge.identity, macBadges[badge.macAddress].identities)) {
						macBadges[badge.macAddress].identities.push(badge.identity);
						$scope.repeatedMacBadges[badge.macAddress] = macBadges[badge.macAddress];
					}
				} else {
					macBadges[badge.macAddress] = {
						identities: [badge.identity]
					}
				}
			}
		}

		/*----------  INIT DECLARATIONS  ----------*/

		function getInitialData() {
			var deferred = $q.defer();
			$http({
					method: 'GET',
					url: '/initial-data'
				})
				.then(function(res) {
					$scope.currentVersion = (res.data.currentVersion);
					deferred.resolve();
				})
				.catch(function(err) {
					deferred.reject(err);
				});

			return deferred.promise;
		}

		function init() {
			getInitialData()
				.then(function() {
					console.log('init complete');
				});
		}

		init();

		/*----------  EVENT LISTENTERS  ----------*/
		$scope.$on('currentBadges', function() {
			compileBadgesById();
			console.log($scope.repeatedIdBadges);
			console.log($scope.repeatedMacBadges);
			$scope.$apply();
		});

		/*----------  EXPORTED FUNCTIONS  ----------*/
		$scope.scanForInterval = scanForInterval;
		$scope.order = order;
		$scope.reset = reset;
	});
angular.module('HubApp')
	.controller('PresyncController', function($scope, $http, $interval, $q, $timeout, badgeService, attendeeService, settingsService) {

		var existingBadges = [];
		var lightBadges = [];

		$scope.currentlyUnsyncing = false;
		$scope.currentBadges = [];

		$scope.currentEvent = null;
		$scope.eventLoading = true;
		$scope.timeThreshold = 2;
		$scope.currentAttendee = null;
		$scope.attendees = [];
		$scope.seenBadges = {};
		$scope.filterSeen = false;

		/*----------  Variables to control UI state (i.e. buttons)  ----------*/
		$scope.syncingAttendee = null;
		$scope.lightingAttendee = null;
		$scope.isCurrentlySyncing = false;

		/*----------  AUTOSYNC  ----------*/
		$scope.autoSync = false;
		$scope.countDownConstant = 5;
		$scope.countDownValue = 0;
		$scope.countDownTimer;

		$scope.syncedAttendees = [];
		$scope.unsyncedAttendees = [];

		/*----------  APPLIED METHODS  ----------*/

		function sortAttendees(attendees) {
			$scope.syncedAttendees = [];
			$scope.unsyncedAttendees = [];

			attendees.forEach(function(attendee) {
				attendee.eventId = $scope.currentEvent;

				if (attendee.badges.length == 0) {
					$scope.unsyncedAttendees.push(attendee);
				} else {
					var hasActiveBadge = false;
					attendee.badges.forEach(function(badge) {
						if (badge.isActive) {
							hasActiveBadge = true;
							attendee.currentBadge = badge;
						}
					});

					if (hasActiveBadge) {
						$scope.syncedAttendees.push(attendee);
					} else {
						$scope.unsyncedAttendees.push(attendee);
					}
				}
			});

			var existingAttendeeBadges = {};
			$scope.attendees.forEach(function(attendee) {
				if (attendee.currentBadge) {
					var uniqueId = attendee.currentBadge.identity + attendee.currentBadge.macAddress;
					existingAttendeeBadges[uniqueId] = attendee.currentBadge;
				}
			});
			badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);

			$scope.currentAttendee = $scope.unsyncedAttendees[0];
		}

		function countDown() {
			$scope.countDownValue--;
			if ($scope.countDownValue > 0) {
				$scope.countDownTimer = $timeout(function() {
					countDown();
				}, 1000);
			} else {
				$scope.syncBadge($scope.currentAttendee);
			}
		}

		$scope.export = function() {
			var csvContent = "data:text/csv;charset=utf-8,";
			csvContent += "#, Event, Attendee Id, First Name, Last Name, Email, Sync Time (UTC), Badge, Sync Source, Badge Order\n";
			$scope.attendees.forEach(function(attendee, index) {
				console.log(attendee);
				csvContent += index + 1 + ",";
				csvContent += $scope.currentEvent + ",";
				csvContent += attendee.id + ",";
				csvContent += attendee.firstname + ",";
				csvContent += attendee.lastname + ",";
				csvContent += attendee.email + ",";

				if (attendee.badges.length > 0) {
					csvContent += attendee.currentBadge.syncTime + ",";
					csvContent += attendee.currentBadge.identity + ",";
					csvContent += attendee.currentBadge.syncSource + ",";
					csvContent += attendee.badgeOrder + ",";
				} else {
					csvContent += ",";
					csvContent += ",";
					csvContent += ",";
					csvContent += ",";
				}

				csvContent += "\n";
			});
			var encodedUri = encodeURI(csvContent);
			window.open(encodedUri);
		}

		$scope.predicate = 'id';
		$scope.reverse = false;
		$scope.order = function(predicate) {
			$scope.reverse = ($scope.predicate === predicate) ? !$scope.reverse : false;
			$scope.predicate = predicate;
		}

		$scope.setCurrentAttendee = function(attendee) {
			if (arrayContains(attendee, $scope.unsyncedAttendees)) {
				$scope.currentAttendee = attendee;
			}
		}

		$scope.setCurrentEvent = function() {
			attendeeService.setCurrentEvent($scope.currentEvent);
			init();
		}

		$scope.setRSSI = function() {
			badgeService.setRssiThreshold($scope.rssiThreshold);
		}

		$scope.toggleLastSeenFilter = function() {
			$scope.filterSeen = !$scope.filterSeen;
		}

		$scope.isSyncingAttendee = function(attendee) {
			return $scope.syncingAttendee === attendee;
		}

		$scope.sendCommand = function(attendee, command) {
			badgeService.sendCommand(attendee.currentBadge, command);
		}

		$scope.toggleAutoSync = function() {
			$scope.autoSync = !$scope.autoSync;
			$scope.countDownValue = $scope.countDownConstant;

			if ($scope.autoSync) {
				countDown();
			} else {
				$timeout.cancel($scope.countDownTimer)
					.then(function(canceled) {
						$scope.countDownValue = $scope.countDownConstant;
					});
			}
		}

		$scope.syncBadge = function(attendee) {
			$scope.isCurrentlySyncing = true;
			$scope.syncingAttendee = attendee;
			badgeService.syncBadge($scope.currentAttendee);
		}

		$scope.unsync = function(attendee) {
			if (!$scope.currentlyUnsyncing) {
				$scope.currentlyUnsyncing = true;
				badgeService.unsyncBadge(attendee, attendee.currentBadge)
					.then(function() {
						attendee.currentBadge.isActive = false;
						attendee.currentBadge = null;
						sortAttendees($scope.attendees);
						$scope.currentlyUnsyncing = false;
						$scope.$apply();
					});
			}
		}

		/*----------  INIT  ----------*/

		var init = function() {
			$scope.eventLoading = true;
			settingsService.getInitialData()
				.then(function(data) {
					$scope.currentEvent = data.currentEvent;
					$scope.rssiThreshold = data.rssiThreshold;
					$scope.currentVersion = data.currentVersion;
					$scope.rssiThreshold = data.rssiThreshold;
					return attendeeService.getAttendeesForEvent($scope.currentEvent);
				})
				.then(function(attendees) {
					$scope.attendees = attendees;
					sortAttendees($scope.attendees);
				})
				.finally(function() {
					$scope.currentStatus = badgeService.currentStatus;
					$scope.eventLoading = false;
				});
		}

		init();

		/*----------  EVENT LISTENERS  ----------*/

		$scope.$on('badgeSynced', function(event, args) {
			$scope.isCurrentlySyncing = false;
			$scope.attendees.forEach(function(attendee) {
				if (attendee.id == args.attendee.id) {
					args.badge.isActive = true;
					attendee.badges.push(args.badge);
					$scope.$apply(attendee.currentBadge = args.badge);
				}
			});

			sortAttendees($scope.attendees);

			if ($scope.autoSync) {
				$scope.countDownValue = $scope.countDownConstant;
				countDown();
			} else {
				$scope.syncingAttendee = null;
			}
		});

		$scope.$on('badgeDisconnect', function() {
			$scope.syncingAttendee = null;
			$scope.autoSync = false;
			$scope.isCurrentlySyncing = false;
			$scope.$apply();
		});

		$scope.$on('seenBadges', function() {
			$scope.$apply($scope.seenBadges = badgeService.seenBadges);
		});

		$scope.$on('currentStatus', function() {
			$scope.currentStatus = badgeService.currentStatus;
			$scope.$apply();
		});

		$scope.$on('currentBadges', function() {
			$scope.$apply($scope.currentBadges = badgeService.currentBadges);
		});

		$scope.$on('badgeNotFound', function() {
			$scope.syncingAttendee = null;
			$scope.autoSync = false;
			$scope.isCurrentlySyncing = false;
			$scope.$apply();
		});
	});
angular.module('HubApp')
    .controller('onsiteController', function($scope, $http, $timeout, $q, utilService, socketService, badgeService, attendeeService, config) {

        /*----------  VAR DECLARATIONS  ----------*/

        var existingBadges = [];
        var lightBadges = [];
        var allCheckIns = [];
        var alert = new Audio('/audio/alert.mp3');

        /*----------  SCOPE VAR DECLARATIONS  ----------*/

        $scope.currentEvent = null;
        $scope.currentWorker = null;
        $scope.rssiThreshold = "...";
        $scope.currentAttendee = null;
        $scope.currentSyncedCheckIn = null;
        $scope.badgeConnected = false;
        $scope.attendees = [];
        $scope.syncingAttendee = null;
        $scope.lightingAttendee = null;
        $scope.currentlySyncing = false;
        $scope.currentlyUnsyncing = false;

        //search
        $scope.searchResults = null;
        $scope.searchTerm = null;
        $scope.currentlySearching = false;

        //checkin arrays
        $scope.unsyncedCheckins = [];
        $scope.syncedCheckins = [];
        $scope.seenSyncedCheckins = [];

        //counts
        $scope.currentBadgesCount = 0;
        $scope.currentAvailableBadgesCount = 0;
        $scope.allocatedBadgesCount = 0;
        $scope.availablePeripheralsCount = 0;
        $scope.allocatedPeripheralsCount = 0;

        //for sorting
        $scope.unsyncedReverse = false;
        $scope.syncedReverse = true;

        //menu
        $scope.checked = false;

        //allocation
        $scope.isAllocating = false;

        //lookups
        $scope.lookedupAttendees = {};

        /*----------  FUNC DECLARATIONS  ----------*/

        var reset = function() {
            badgeService.reset()
                .then(function() {
                    $scope.availablePeripheralsCount = badgeService.availablePeripheralsCount;
                    $scope.allocatedPeripheralsCount = badgeService.allocatedPeripheralsCount;
                    $scope.$apply();
                });
        }

        var setCurrentAttendee = function(attendee) {
            if (!$scope.currentlySyncing) {
                if ($scope.currentAttendee) {
                    if ($scope.currentAttendee.id == attendee.id) {
                        $scope.currentAttendee = null;
                    } else {
                        $scope.currentAttendee = attendee;
                    }
                } else {
                    $scope.currentAttendee = attendee;
                }
            }
        }

        var setCurrentSyncedCheckIn = function(checkIn) {
            if (!$scope.currentlyUnsyncing) {
                if ($scope.currentSyncedCheckIn) {
                    if ($scope.currentSyncedCheckIn.id == checkIn.id) {
                        $scope.currentSyncedCheckIn = null;
                    } else {
                        $scope.currentSyncedCheckIn = checkIn;
                    }
                } else {
                    $scope.currentSyncedCheckIn = checkIn;
                }
            }
        }


        var sortCheckIns = function() {
            $scope.unsyncedCheckins = [];
            $scope.syncedCheckins = [];
            allCheckIns.forEach(function(checkIn) {
                if (!checkIn.badge) {
                    $scope.unsyncedCheckins.push(checkIn);
                } else {
                    $scope.syncedCheckins.push(checkIn);
                }
            });
        }

        var removeBadgeForCheckIn = function(checkInTemp) {
            allCheckIns.forEach(function(checkIn) {
                if (checkIn.id == checkInTemp.id) {
                    checkIn.badge = null;
                }
            });
        }

        var addBadgeForCheckIn = function(checkInTemp, badge) {
            allCheckIns.forEach(function(checkIn) {
                if (checkIn.id == checkInTemp.id) {
                    checkIn.badge = badge;
                }
            });
        }

        var updateSeenSyncedCheckIns = function(badges) {
            $scope.seenSyncedCheckins = [];
            $scope.seenSyncedCheckins = allCheckIns.filter(function(checkIn) {
                if (checkIn.badge) {
                    var matches = false;
                    badges.forEach(function(badge) {
                        if (checkIn.badge.identity == badge.identity &&
                            checkIn.badge.macAddress == badge.macAddress) {
                            matches = true;
                        }
                    });

                    return matches;
                }
            });
        }

        var allocate = function() {
            console.log($scope.availablePeripheralsCount < 1);
            if ($scope.availablePeripheralsCount > 0) {
                console.log('the fuck?');
                if (!$scope.isAllocating) {
                    $scope.isAllocating = true;
                    badgeService.allocate();
                    $timeout(function() {
                        $scope.isAllocating = false;
                    }, 5 * 1000);
                }
            } else {
                alert('You don\'t have any available badges to allocate!');
            }
        }

        var search = function() {
            if (search && search !== "") {
                $scope.currentlySearching = true;
                attendeeService.searchBoomsetCheckIns($scope.currentEvent, $scope.searchTerm)
                    .then(function(data) {
                        $scope.currentlySearching = false;
                        $scope.searchResults = data.data;
                    });
            }
        }

        var scanForInterval = function() {
            if (!$scope.isScanning) {
                $scope.isScanning = true;
                badgeService.scanForInterval(3, false)
                    .then(function() {
                        $scope.isScanning = false;
                    });
            }
        }

        var startLookup = function() {
            $scope.currentlyLookingUp = true;
            badgeService.startLookup()
                .then(function() {

                });
        }

        $scope.toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        $scope.orderUnsynced = function(predicate) {
            $scope.unsyncedReverse = ($scope.unsyncedPredicate === predicate) ? !$scope.unsyncedReverse : false;
            $scope.unsyncedPredicate = predicate;
            console.log($scope.unsyncedReverse);
        }

        $scope.orderSynced = function(predicate) {
            console.log('order synced!');
            $scope.syncedReverse = ($scope.syncedPredicate === predicate) ? !$scope.syncedReverse : false;
            $scope.syncedPredicate = predicate;
        }

        $scope.attendeeBadgeWaitingToLight = function(attendee) {
            if (attendee.badgeIdentity) {
                return (lightBadges.indexOf(attendee.badgeIdentity) > -1);
            } else {
                return false;
            }
        }

        $scope.sendCommand = function(command) {
            if ($scope.currentSyncedCheckIn.badge) {
                badgeService.sendCommand($scope.currentSyncedCheckIn.badge, command);
            }
        }

        $scope.syncBadge = function() {
            if ($scope.currentAttendee && !$scope.currentlySyncing && badgeService.allocatedPeripheralsCount > 0) {
                $scope.currentlySyncing = true;
                badgeService.syncBadge($scope.currentAttendee);
            }
        }

        $scope.unsync = function() {
            if (!$scope.currentlyUnsyncing && $scope.currentSyncedCheckIn && $scope.currentSyncedCheckIn.badge) {
                $scope.currentlyUnsyncing = true;
                console.log($scope.currentlyUnsyncing);
                badgeService.unsyncBadge($scope.currentSyncedCheckIn.eventAttendee, $scope.currentSyncedCheckIn.badge)
                    .then(function() {
                        removeBadgeForCheckIn($scope.currentSyncedCheckIn);
                        sortCheckIns();

                        var existingAttendeeBadges = {};
                        allCheckIns.forEach(function(checkIn) {
                            if (checkIn.badge) {
                                var uniqueId = checkIn.badge.identity + checkIn.badge.macAddress;
                                existingAttendeeBadges[uniqueId] = checkIn.badge;
                            }
                        });
                        badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);

                        $scope.currentSyncedCheckIn = null;
                        $scope.currentlyUnsyncing = false;
                    });
            }
        }

        $scope.setRSSI = function() {
            badgeService.setRssiThreshold($scope.rssiThreshold);
        }

        /*----------  INIT FUNCTION DECLARATIONS  ----------*/

        var getInitialData = function() {
            var deferred = $q.defer();
            $http({
                    method: 'GET',
                    url: '/initial-data'
                })
                .then(function(res) {
                    $scope.currentEvent = parseInt(res.data.currentEvent);
                    $scope.currentWorker = parseInt(res.data.currentWorker);
                    $scope.currentVersion = res.data.currentVersion;
                    $scope.allocationEnabled = res.data.allocationEnabled;
                    deferred.resolve();
                })
                .catch(function(err) {
                    deferred.reject(err);
                });

            return deferred.promise;
        }

        var init = function() {
            $scope.eventLoading = true;
            getInitialData()
                .then(function() {
                    return attendeeService.getBoomsetCheckIns($scope.currentEvent, $scope.currentWorker, "")
                })
                .then(function(checkIns) {
                    allCheckIns = checkIns;
                    sortCheckIns();
                })
                .finally(function() {
                    var existingAttendeeBadges = {};
                    allCheckIns.forEach(function(checkIn) {
                        if (checkIn.badge) {
                            var uniqueId = checkIn.badge.identity + checkIn.badge.macAddress;
                            existingAttendeeBadges[uniqueId] = checkIn.badge;
                        }
                    });
                    badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);
                    $scope.currentStatus = badgeService.currentStatus;
                });

            $timeout(function() {
                init();
            }, 10 * 1000);
        }

        init();

        /*----------  EVENT LISTENERS  ----------*/


        /*----------  EXPORT DECLARATIONS  ----------*/
        $scope.search = search;
        $scope.setCurrentAttendee = setCurrentAttendee;
        $scope.setCurrentSyncedCheckIn = setCurrentSyncedCheckIn;
        $scope.allocate = allocate;
        $scope.scanForInterval = scanForInterval;
        $scope.reset = reset;

    });
angular.module('HubApp')
    .controller('onsiteController', function($scope, $http, $timeout, $q, utilService, socketService, badgeService, attendeeService, config, $location) {

        /*----------  VAR DECLARATIONS  ----------*/

        var existingBadges = [];
        var lightBadges = [];
        var allCheckIns = [];
        var alert = new Audio('/audio/alert.mp3');

        /*----------  SCOPE VAR DECLARATIONS  ----------*/

        $scope.currentEvent = null;
        $scope.currentWorker = null;
        $scope.rssiThreshold = "...";
        $scope.currentAttendee = null;
        $scope.currentSyncedCheckIn = null;
        $scope.badgeConnected = false;
        $scope.attendees = [];
        $scope.syncingAttendee = null;
        $scope.lightingAttendee = null;
        $scope.currentlySyncing = false;
        $scope.currentlyUnsyncing = false;

        //search
        var searchResults = null;
        $scope.searchTerm = null;
        $scope.currentlySearching = false;
        $scope.syncedSearchResults = [];
        $scope.unsyncedSearchResults = [];

        //checkin arrays
        $scope.unsyncedCheckins = [];
        $scope.syncedCheckins = [];
        $scope.seenSyncedCheckins = [];

        //counts
        $scope.currentBadgesCount = 0;
        $scope.currentAvailableBadgesCount = 0;
        $scope.allocatedBadgesCount = 0;
        $scope.availablePeripheralsCount = 0;
        $scope.allocatedPeripheralsCount = 0;

        //for sorting
        $scope.unsyncedReverse = false;
        $scope.syncedReverse = true;

        //menu
        $scope.checked = false;

        //allocation
        $scope.isAllocating = false;

        //lookups
        $scope.lookedupAttendees = {};
        var currentlyLooking = {};
        
        //url location
        $scope.location = $location;
        console.log($location.search());
        $scope.$watch('location.search()', function() {
            $scope.currentEvent = ($location.search()).currentEvent;
            $scope.currentWorker = ($location.search()).currentWorker;
        }, true);

        $scope.changeTarget = function(name) {
            $location.search('currentEvent', name);
            $location.search('currentWorker', name);
        }

        /*----------  FUNC DECLARATIONS  ----------*/

        var reset = function() {
            badgeService.reset()
                .then(function() {
                    $scope.lookedupAttendees = {};
                    $scope.availablePeripheralsCount = badgeService.availablePeripheralsCount;
                    $scope.allocatedPeripheralsCount = badgeService.allocatedPeripheralsCount;
                    $scope.$apply();
                });
        }

        var setCurrentAttendee = function(attendee) {
            if (!$scope.currentlySyncing) {
                if ($scope.currentAttendee) {
                    if ($scope.currentAttendee.id == attendee.id) {
                        $scope.currentAttendee = null;
                    } else {
                        $scope.currentAttendee = attendee;
                    }
                } else {
                    $scope.currentAttendee = attendee;
                }
            }
        }

        var setCurrentSyncedCheckIn = function(checkIn) {
            if (!$scope.currentlyUnsyncing) {
                if ($scope.currentSyncedCheckIn) {
                    if ($scope.currentSyncedCheckIn.id == checkIn.id) {
                        $scope.currentSyncedCheckIn = null;
                    } else {
                        $scope.currentSyncedCheckIn = checkIn;
                    }
                } else {
                    $scope.currentSyncedCheckIn = checkIn;
                }
            }
        }

        var sortCheckIns = function() {
            $scope.unsyncedCheckins = [];
            $scope.syncedCheckins = [];
            allCheckIns.forEach(function(checkIn) {
                if (!checkIn.badge) {
                    $scope.unsyncedCheckins.push(checkIn);
                } else {
                    $scope.syncedCheckins.push(checkIn);
                }
            });
        }

        var removeBadgeForCheckIn = function(checkInTemp) {
            allCheckIns.forEach(function(checkIn) {
                if (checkIn.id == checkInTemp.id) {
                    checkIn.badge = null;
                }
            });
        }

        var addBadgeForCheckIn = function(checkInTemp, badge) {
            allCheckIns.forEach(function(checkIn) {
                if (checkIn.id == checkInTemp.id) {
                    checkIn.badge = badge;
                }
            });
        }

        var updateSeenSyncedCheckIns = function(badges) {
            $scope.seenSyncedCheckins = [];
            $scope.seenSyncedCheckins = allCheckIns.filter(function(checkIn) {
                if (checkIn.badge) {
                    var matches = false;
                    badges.forEach(function(badge) {
                        if (checkIn.badge.identity == badge.identity &&
                            checkIn.badge.macAddress == badge.macAddress) {
                            matches = true;
                        }
                    });

                    return matches;
                }
            });
        }

        var allocate = function() {
            console.log($scope.availablePeripheralsCount < 1);
            if ($scope.availablePeripheralsCount > 0) {
                if (!$scope.isAllocating) {
                    $scope.isAllocating = true;
                    badgeService.allocate();
                    $timeout(function() {
                        $scope.isAllocating = false;
                    }, 5 * 1000);
                }
            } else {
                alert('You don\'t have any available badges to allocate!');
            }
        }

        var search = function() {
            if (search && search !== "") {
                $scope.currentlySearching = true;
                attendeeService.searchBoomsetCheckIns($scope.currentEvent, $scope.searchTerm)
                    .then(function(data) {
                        $scope.currentlySearching = false;
                        searchResults = data.data;
                        sortSearchResults();
                    });
            }
        }

        var sortSearchResults = function() {
            searchResults.forEach(function(result) {
                console.log(result);
                if(result.badge) {
                    $scope.syncedSearchResults.push(result);
                } else {
                    $scope.unsyncedSearchResults.push(result);
                }
            });
        }

        var scanForInterval = function() {
            if (!$scope.isScanning) {
                $scope.isScanning = true;
                badgeService.scanForInterval(3, false)
                    .then(function() {
                        $scope.isScanning = false;
                    });
            }
        }

        $scope.toggleMenu = function() {
            $scope.checked = !$scope.checked;
        }

        $scope.orderUnsynced = function(predicate) {
            $scope.unsyncedReverse = ($scope.unsyncedPredicate === predicate) ? !$scope.unsyncedReverse : false;
            $scope.unsyncedPredicate = predicate;
            console.log($scope.unsyncedReverse);
        }

        $scope.orderSynced = function(predicate) {
            console.log('order synced!');
            $scope.syncedReverse = ($scope.syncedPredicate === predicate) ? !$scope.syncedReverse : false;
            $scope.syncedPredicate = predicate;
        }

        $scope.attendeeBadgeWaitingToLight = function(attendee) {
            if (attendee.badgeIdentity) {
                return (lightBadges.indexOf(attendee.badgeIdentity) > -1);
            } else {
                return false;
            }
        }

        $scope.sendCommand = function(command) {
            if ($scope.currentSyncedCheckIn.badge) {
                badgeService.sendCommand($scope.currentSyncedCheckIn.badge, command);
            }
        }

        $scope.syncBadge = function() {
            if ($scope.currentAttendee && !$scope.currentlySyncing && badgeService.allocatedPeripheralsCount > 0) {
                $scope.currentlySyncing = true;
                badgeService.syncBadge($scope.currentAttendee);
            }
        }

        $scope.unsync = function() {
            if (!$scope.currentlyUnsyncing && $scope.currentSyncedCheckIn && $scope.currentSyncedCheckIn.badge) {
                $scope.currentlyUnsyncing = true;
                console.log($scope.currentlyUnsyncing);
                badgeService.unsyncBadge($scope.currentSyncedCheckIn.eventAttendee, $scope.currentSyncedCheckIn.badge)
                    .then(function() {
                        removeBadgeForCheckIn($scope.currentSyncedCheckIn);
                        sortCheckIns();

                        var existingAttendeeBadges = {};
                        allCheckIns.forEach(function(checkIn) {
                            if (checkIn.badge) {
                                var uniqueId = checkIn.badge.identity + checkIn.badge.macAddress;
                                existingAttendeeBadges[uniqueId] = checkIn.badge;
                            }
                        });
                        badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);

                        $scope.currentSyncedCheckIn = null;
                        $scope.currentlyUnsyncing = false;
                    });
            }
        }

        $scope.syncSearched = function() {
            if ($scope.currentAttendee && !$scope.currentlySyncing && badgeService.allocatedPeripheralsCount > 0) {
                $scope.currentlySyncing = true;
                badgeService.syncBadge($scope.currentAttendee);
            }
        }

        $scope.unsyncSearched = function() {
            if (!$scope.currentlyUnsyncing && $scope.currentSyncedCheckIn && $scope.currentSyncedCheckIn.badge) {
                $scope.currentlyUnsyncing = true;
                console.log($scope.currentlyUnsyncing);
                badgeService.unsyncBadge($scope.currentSyncedCheckIn.eventAttendee, $scope.currentSyncedCheckIn.badge)
                    .then(function() {
                        removeBadgeForCheckIn($scope.currentSyncedCheckIn);
                        sortCheckIns();

                        var existingAttendeeBadges = {};
                        allCheckIns.forEach(function(checkIn) {
                            if (checkIn.badge) {
                                var uniqueId = checkIn.badge.identity + checkIn.badge.macAddress;
                                existingAttendeeBadges[uniqueId] = checkIn.badge;
                            }
                        });
                        badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);

                        $scope.currentSyncedCheckIn = null;
                        $scope.currentlyUnsyncing = false;
                    });
            }
        }

        $scope.unsyncAttendee = function() {
            $scope.currentAttendee.eventId = $scope.currentEvent;
            if (!$scope.currentlyUnsyncing && $scope.currentAttendee) {
                $scope.currentlyUnsyncing = true;
                badgeService.unsyncBadge($scope.currentAttendee, $scope.currentAttendee.badges[0])
                    .then(function() {
                        $scope.lookedupAttendees = [];
                        $scope.currentlyUnsyncing = false;
                    });
            }
        }

        $scope.setRSSI = function() {
            badgeService.setRssiThreshold($scope.rssiThreshold);
        }

        /*----------  INIT FUNCTION DECLARATIONS  ----------*/

        var getInitialData = function() {
            var deferred = $q.defer();
            $http({
                    method: 'GET',
                    url: '/initial-data'
                })
                .then(function(res) {
                    // $scope.currentEvent = parseInt(res.data.currentEvent);
                    // $scope.currentWorker = parseInt(res.data.currentWorker);
                    $scope.currentVersion = res.data.currentVersion;
                    $scope.allocationEnabled = res.data.allocationEnabled;
                    deferred.resolve();
                })
                .catch(function(err) {
                    deferred.reject(err);
                });

            return deferred.promise;
        }

        var init = function() {
            $scope.eventLoading = true;
            getInitialData()
                .then(function() {
                    return attendeeService.getBoomsetCheckIns($scope.currentEvent, $scope.currentWorker, "")
                })
                .then(function(checkIns) {
                    console.log(checkIns.length);
                    allCheckIns = checkIns;
                    sortCheckIns();
                })
                .finally(function() {
                    var existingAttendeeBadges = {};
                    allCheckIns.forEach(function(checkIn) {
                        if (checkIn.badge) {
                            var uniqueId = checkIn.badge.identity + checkIn.badge.macAddress;
                            existingAttendeeBadges[uniqueId] = checkIn.badge;
                        }
                    });
                    badgeService.updateExistingAttendeeBadges(existingAttendeeBadges);
                    $scope.currentStatus = badgeService.currentStatus;
                    if($scope.lookup) {
                        badgeService.triggerLookup();
                    }
                });

            $timeout(function() {
                init();
            }, 1 * 1000);
        }

        init();

        /*----------  EVENT LISTENERS  ----------*/

        $scope.$on('badgeSynced', function(event, args) {
            var checkIn = attendeeService.findCheckInForAttendee(args.attendee, allCheckIns);

            if (checkIn) {
                addBadgeForCheckIn(checkIn, args.badge);
                sortCheckIns();
            }

            $scope.currentlySyncing = false;
            if ($scope.unsyncedCheckins.length > 0) {
                $scope.currentAttendee = $scope.unsyncedCheckins[0].eventAttendee;
            } else {
                $scope.currentAttendee = null;
            }

            alert.play();
            $scope.$apply();
        });

        $scope.$on('badgeDisconnect', function() {
            $scope.currentlySyncing = false;
            $scope.$apply();
        });

        $scope.$on('currentStatus', function() {
            $scope.currentStatus = badgeService.currentStatus;
            $scope.$apply();
        });

        $scope.$on('badgeNotFound', function() {
            $scope.$apply($scope.currentAttendee = null);
            $scope.$apply($scope.currentlySyncing = false);
        });

        $scope.$on('currentBadges', function() {
            $scope.$apply($scope.currentBadgesCount = badgeService.currentBadges.length);
            $scope.$apply($scope.currentAvailableBadgesCount = badgeService.currentAvailableBadges.length);
            $scope.$apply($scope.allocatedPeripheralsCount = badgeService.allocatedPeripheralsCount);
            $scope.$apply($scope.availablePeripheralsCount = badgeService.availablePeripheralsCount);

            updateSeenSyncedCheckIns(badgeService.currentBadges);
        });

        $scope.$on('badgeLookup', function(event, args) {
            if(!currentlyLooking[args.identity]) {
                currentlyLooking[args.identity] = 1;

                attendeeService.getAttendeeForBadge($scope.currentEvent, args.identity)
                    .then(function(attendee) {
                        console.log(attendee);
                        delete currentlyLooking[args.identity];
                        if(attendee) {
                            $scope.lookedupAttendees[args.identity] = attendee;
                        } else {
                            alert('No attendee found for badge!');
                        }
                    });
            }
        });

        /*----------  EXPORT DECLARATIONS  ----------*/
        $scope.search = search;
        $scope.setCurrentAttendee = setCurrentAttendee;
        $scope.setCurrentSyncedCheckIn = setCurrentSyncedCheckIn;
        $scope.allocate = allocate;
        $scope.scanForInterval = scanForInterval;
        $scope.reset = reset;

    });
angular.module('HubApp')
	.factory('attendeeService', function($rootScope, $q, $http, utilService, socketService, config) {
		var attendeeService = {};
		var socket = socketService.socket;

		attendeeService.currentSyncingAttendee = null;
		attendeeService.existingAttendeeBadges = {};

		/**
		 * Description: get check-in records based on current event and check-in service
		 * 
		 * @param  {Number} eventId        , the event id
		 * @param  {String} checkInService , the check-in service name
		 * @param  {Number} workerId       , the check-in worker id (optional)
		 * @return {Array}                 , an array of check-in records
		 */
		var getCheckInRecords = function(eventId, checkInService, workerId) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/checkins/providers/'+ checkInService;
			if (workerId) {
				url += '/workers/'+workerId;
			}
			$http({
				method: 'GET',
				url: url,
				params: {
					"eventId": eventId,
					"fromTime": "0"
				}
			}).then(function(res) {
				deferred.resolve(res.data);
			});
			return deferred.promise;
		};

		var getOnsiteWalkups = function(eventId, sinceTime) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/onsite/attendees';
			$http({
				method: 'GET',
				url: url,
				params: {
					eventId: eventId,
					isCheckIn: 'false',
					registerFromTime: sinceTime
				}
			}).then(function(res) {
				deferred.resolve(res.data);
			});
			return deferred.promise;
		};

		var getOnsiteCheckIns = function(eventId, checkInWorker, sinceTime) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/onsite/attendees';
			$http({
				method: 'GET',
				url: url,
				params: {
					eventId: eventId,
					isCheckIn: 'true',
					checkInWorker: checkInWorker,
					checkInFromTime: sinceTime ? sinceTime : 0
				}
			}).then(function(res) {
				deferred.resolve(res.data);
			});
			return deferred.promise;
		};

		var getBoomsetCheckIns = function(eventId, workerId, keyword) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/checkins/providers/boomset/workers/' + workerId;
			$http({
				method: 'GET',
				url: url,
				params: {
					"eventId": eventId,
					"fromTime": "0"
				}
			}).
			then(function(res) {
				deferred.resolve(res.data);
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var searchBoomsetCheckIns = function(eventId, keyword) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/onsite/attendees/search';
			console.log(url);
			$http({
				method: 'GET',
				url: url,
				params: {
					"eventId": eventId,
					"q": keyword
				}
			}).
			then(function(res) {
				deferred.resolve(res);
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var getAttendeesForEvent = function(eventId) {
			var deferred = $q.defer();

			$http({
				method: 'GET',
				url: config.baseUrl + '/events/' + eventId + '/eventattendees',
				headers: {
					'Loopd-Admin-Key': config.authToken
				},
				params: {
					"requestFrom": "home",
					"requestFromId": "unknown"
				}
			}).
			then(function(res) {
				deferred.resolve(res.data);
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		var findAvailableBadgeForAttendee = function(attendee) {
			attendeeService.currentSyncingAttendee = attendee;

			$http({
				method: 'POST',
				url: '/sync-one',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					currentAttendee: attendee,
					rssiThreshold: $scope.rssiThreshold
				}
			}).
			success(function(data, status, headers, config) {

			}).
			error(function(data, status, headers, config) {
				console.error(data);
			});
		}

		var findCheckInForAttendee = function(attendee, checkIns) {
			for (var x = 0; x <= checkIns.length; x++) {
				if (checkIns[x].eventAttendee.id == attendee.id) {
					return checkIns[x];
				}
			}

			return null;
		}

		var setCurrentEvent = function(eventId) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/current-event',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					eventId: eventId,
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve();
			}).
			error(function(data, status, headers, config) {
				deferred.reject();
			});

			return deferred.promise;
		}

		var getAttendeeForBadge = function(eventId, identity) {
			var deferred = $q.defer();
			var url = config.baseUrl + '/Events/' + eventId + '/eventattendees';
			console.log(url);
			$http({
				method: 'GET',
				url: url,
				headers: {
					'Loopd-Admin-Key': config.authToken
				},
				params: {
					"requestFrom": "WEB",
					"requestFromId": 123,
					"badge": identity
				}
			}).
			then(function(res) {
				if(res.data.length > 0) {
					deferred.resolve(res.data[0]);
				} else {
					deferred.resolve(null);
				}
			}, function(data, status, headers, config) {
				// console.log(data.meta);
			});

			return deferred.promise;
		}

		/*----------  EXPORT DECLARTIONS  ----------*/
		attendeeService.getOnsiteCheckIns = getOnsiteCheckIns;
		attendeeService.getOnsiteWalkups = getOnsiteWalkups;
		attendeeService.getBoomsetCheckIns = getBoomsetCheckIns;
		attendeeService.getCheckInRecords = getCheckInRecords;
		attendeeService.findCheckInForAttendee = findCheckInForAttendee;
		attendeeService.searchBoomsetCheckIns = searchBoomsetCheckIns;
		attendeeService.getAttendeesForEvent = getAttendeesForEvent;
		attendeeService.setCurrentEvent = setCurrentEvent;
		attendeeService.getAttendeeForBadge = getAttendeeForBadge;

		return attendeeService;
	});
angular.module('HubApp')
	.factory('badgeService', function($rootScope, $q, $http, utilService, socketService, attendeeService, config) {
		var badgeService = {};
		var socket = socketService.socket;

		/*----------  VAR DECLARATIONS  ----------*/

		badgeService.currentStatus = 'Waiting for command...';
		badgeService.seenBadgesCount = 0;
		badgeService.currentBadges = [];
		badgeService.currentAvailableBadges = [];
		badgeService.seenBadges = {};
		badgeService.attendeesWaitingToSync = {};
		badgeService.badgesWaitingForCommand = {};
		badgeService.existingAttendeeBadges = {};
		badgeService.rssiThreshold = "...";
		badgeService.isScanning = false;
		badgeService.bulkCommanding = false;

		//peripheral counts
		badgeService.availablePeripheralsCount = 0;
		badgeService.allocatedPeripheralsCount = 0;

		/*----------  FUNC DECLARATIONS  ----------*/

		//resets the count of seenbadges
		var reset = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/reset',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				badgeService.seenBadges = {};
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//toggles allocation of badges where speed is increased if nearby
		var allocate = function() {
			var deferred = $q.defer();

			$http({
				method: 'GET',
				url: '/allocate',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		var scanForInterval = function(scanTime, detectDuplicates) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/scan',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					scanTime: scanTime,
					detectDuplicates: detectDuplicates
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		var scanForAvailable = function(scanTime) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/scan',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					scanTime: scanTime,
					onlyAvailable: true
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//sends a designated command to the badge
		var sendCommand = function(badge, command) {
			var uniqueId = badge.identity + badge.macAddress;
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/command-badge',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					badge: badge,
					badgeCommand: command
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				delete badgeService.badgesWaitingForCommand[uniqueId];
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//sends a designated command to the badge
		var sendBulkCommand = function(state, command) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/bulk-command',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					state: state,
					bulkBadgeCommand: command
				}
			}).
			success(function(data, status, headers, config) {
				badgeService.bulkCommanding = true;
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		var cancelBulkCommand = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/cancel-bulk-command',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				badgeService.bulkCommanding = false;
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//tells the backend to communicate with the server to tie the badge id to attendee
		var syncBadge = function(attendee) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/sync-badge',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					attendee: attendee
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				delete badgeService.badgesWaitingForCommand[attendee.id];
				deferred.reject(data);
			});

			return deferred.promise;
		}

		//sets the rssi threshold in which commands/synchronizations can be sent
		var setRssiThreshold = function(value) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/set-rssi',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					rssiThreshold: $scope.rssiThreshold
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		//takes in an object with idMac as unique key with value as badge object
		var updateExistingAttendeeBadges = function(existingAttendeeBadges) {
			var deferred = $q.defer();
			badgeService.existingAttendeeBadges = existingAttendeeBadges;

			$http({
				method: 'POST',
				url: '/update-existing-badges',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					existingBadges: badgeService.existingAttendeeBadges,
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		//this turns on the 
		var triggerLookup = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/trigger-lookup',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		//removes the relationship between the attendee and badge
		var unsyncBadge = function(attendee, badge) {
			var deferred = $q.defer();
			var baseConfig = config;
			console.log(badge);

			$http({
				method: 'POST',
				url: '/unsync-badge',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					badge: badge
				}
			}).
			success(function(data) {
				$http({
					method: 'DELETE',
					url: config.baseUrl + '/Events/' + attendee.eventId + '/badges/' + badge.identity,
					headers: {
						'Loopd-Admin-Key': config.authToken
					},
					params: {
						"source": "WEB_E",
						"sourceId": "WE:WE:WE",
						"isReturned": true
					}
				}).
				success(function(data, status, headers, config) {
					attendee.badgeIdentity = null;
					deferred.resolve(data);
				}).
				error(function(data, status, headers, config) {
					deferred.reject(data);
				});

			}).
			error(function(data, status, headers, config) {
				deferred.reject();
			});

			return deferred.promise;
		}

		var setRssiThreshold = function(rssiThreshold) {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/rssi-threshold',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					rssiThreshold: rssiThreshold,
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve();
			}).
			error(function(data, status, headers, config) {
				deferred.reject();
			});

			return deferred.promise;
		}

		var startLookup = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/start-lookup',
				headers: {
					'Content-Type': 'application/json'
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve();
			}).
			error(function(data, status, headers, config) {
				deferred.reject();
			});

			return deferred.promise;
		}

		/*----------  SOCKET LISTENERS  ----------*/

		socket.on('currentStatus', function(data) {
			badgeService.currentStatus = data.status.toString();
			$rootScope.$broadcast('currentStatus');
		});

		socket.on('alert', function(data) {
			alert(data.message);
		});

		socket.on('logMessage', function(data) {
			console.log('%c (' + new Date().toLocaleTimeString() + ') ' + data.log, 'color: #009afd');
		});

		socket.on('currentBadges', function(data) {
			badgeService.seenBadges = data.seenBadges;
			badgeService.currentBadges = data.currentBadges;
			badgeService.currentAvailableBadges = data.currentAvailableBadges;
			badgeService.allocatedPeripheralsCount = data.allocatedPeripheralsCount;
			badgeService.availablePeripheralsCount = data.availablePeripheralsCount;
			$rootScope.$broadcast('currentBadges');
		});

		socket.on('badgeCommand', function(data) {
			var uniqueId = data.badge.identity + data.badge.macAddress;
			delete badgeService.badgesWaitingForCommand[uniqueId];
		});

		socket.on('badgeConnected', function(data) {
			if (data.connected == true) {
				$scope.$apply($scope.badgeConnected = true);
			} else {
				$scope.$apply($scope.badgeConnected = false);
			}
		});

		socket.on('badgeSynced', function(data) {
			$rootScope.$broadcast('badgeSynced', {
				attendee: data.attendee,
				badge: data.badge
			});
		});

		socket.on('badgeDisconnect', function(data) {
			console.log('badge disconnect called!');
			$rootScope.$broadcast('badgeDisconnect');
		});

		socket.on('badgeNotFound', function(data) {
			// alert(data.message);
			$rootScope.$broadcast('badgeNotFound');
		});

		socket.on('badgeLookup', function(data) {
			$rootScope.$broadcast('badgeLookup', {
				identity: data.identity
			});
		});

		socket.on('bulkCommandComplete', function() {
			badgeService.bulkCommanding = false;
			$rootScope.$broadcast('bulkCommandComplete');
		});

		socket.on('connect', function() {
			console.log("socket connection");
		});

		socket.on('disconnect', function() {
			console.log('socket disconnection!');
			socket.connect();
		});

		/*----------  EXPORT DECLARATIONS  ----------*/
		badgeService.reset = reset;
		badgeService.sendCommand = sendCommand;
		badgeService.sendBulkCommand = sendBulkCommand;
		badgeService.syncBadge = syncBadge;
		badgeService.unsyncBadge = unsyncBadge;
		badgeService.updateExistingAttendeeBadges = updateExistingAttendeeBadges;
		badgeService.allocate = allocate;
		badgeService.scanForInterval = scanForInterval;
		badgeService.setRssiThreshold = setRssiThreshold;
		badgeService.triggerLookup = triggerLookup;

		return badgeService;
	});
'use strict';
angular.module('HubApp')
    .factory('loginService', function($http) {
        return {
            loginAsync: function(username, password) {
                return $http.post('/api/v1/login', {
                    username: username,
                    password: password
                }).success(function(data, status) {
                    return data;
                }).error(function(data, status) {
                    console.log('fail to login with response:', data);
                });
            }
        };
    });

angular.module('HubApp')
	.factory('settingsService', function($http, $q) {
		var settingsService = {};

		var setRSSI = function() {
			var deferred = $q.defer();
			$http({
				method: 'POST',
				url: '/set-rssi',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					rssiThreshold: $scope.rssiThreshold
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
				console.log(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		var setCurrentEvent = function() {
			var deferred = $q.defer();

			$http({
				method: 'POST',
				url: '/current-event',
				headers: {
					'Content-Type': 'application/json'
				},
				data: {
					currentEvent: $scope.currentEvent,
				}
			}).
			success(function(data, status, headers, config) {
				deferred.resolve(data);
				console.log(data);
			}).
			error(function(data, status, headers, config) {
				deferred.reject(data);
				console.error(data);
			});

			return deferred.promise;
		}

		var getInitialData = function() {
			var deferred = $q.defer();
			$http({
					method: 'GET',
					url: '/initial-data'
				})
				.then(function(res) {
					deferred.resolve(res.data);
				})
				.catch(function(err) {
					deferred.reject(err);
				});

			return deferred.promise;
		}

		settingsService.getInitialData = getInitialData;

		return settingsService;
	});
angular.module('HubApp')
	.factory('socketService', function() {
		var socket = io.connect();
		return {
			socket: socket
		}
	});
angular.module('HubApp')
	.factory('utilService', function() {
		var util = {};

		/*----------  ARRAY METHODS  ----------*/
		var arrayContains = function(needle, arrhaystack) {
			return (arrhaystack.indexOf(needle) > -1);
		}

		var removeFromArray = function(needle, arrhaystack) {
			var index = arrhaystack.map(function(x) {
				return needle;
			}).indexOf(needle);
			arrhaystack.splice(index, 1);
		}

		var objectExistsInArray = function(prop, value, arrhaystack) {
			arrhaystack.forEach(function(object) {
				if (object[prop] === value) {
					return true;
				}
			});

			return false;
		}

		var findObjectInArray = function(prop, value, arrhaystack) {
			arrhaystack.forEach(function(object, index) {
				if (object[prop] === value) {
					return index;
				}
			});

			return -1;
		}

		var findIndexByIdentityAndMac = function(identity, macAddress, arrayhaystack) {
			for (var i = 0; i < arrayhaystack.length; i += 1) {
				if (arrayhaystack[i]['macAddress'] === macAddress && arrayhaystack[i]['identity'] === identity) {
					return i;
				}
			}

			return -1;
		}

		var getSortedArrayFromObject = function(property, object, reverse) {
			return Object.keys(object).sort(function(a, b) {
				var aProp = (typeof object[a][property] === 'undefined' || object[a][property] === null) ? 0 : object[a][property];
				var bProp = (typeof object[b][property] === 'undefined' || object[b][property] === null) ? 0 : object[b][property];

				if (reverse) {
					return bProp - aProp;
				} else {
					return aProp - bProp;
				}
			});
		}

		util.arrayContains = arrayContains;
		util.removeFromArray = removeFromArray;
		util.objectExistsInArray = objectExistsInArray;
		util.findObjectInArray = findObjectInArray;
		util.findIndexByIdentityAndMac = findIndexByIdentityAndMac;
		util.getSortedArrayFromObject = getSortedArrayFromObject;

		return util;
	});